# Learning Algorithms and Data Structures

## Core Data Structures

### Arrays

- Basic operations: access, insertion, deletion
- Dynamic arrays

### Linked Lists

- Singly, doubly, and circular linked lists
- Common operations: insertion, deletion, traversal, searching

### Stacks

- LIFO (Last-In, First-Out) principle
- Operations: push, pop, peek
- Applications: expression evaluation, function call stacks

### Queues

- FIFO (First-In, First-Out) principle
- Operations: enqueue, dequeue, peek
- Applications: breadth-first search, task scheduling

### Hash Tables (Hash Maps)

- Concepts of hashing
- Collision resolution: separate chaining, open addressing
- Average and worst-case time complexity for insertion, deletion, search

### Trees

#### Binary Trees

- Basic properties
- Traversal methods: in-order, pre-order, post-order

#### Binary Search Trees (BSTs)

- Insertion, deletion, searching
- Time complexity
- Importance of balance

#### Heaps

- Binary heaps: min-heap, max-heap
- Heapify operation
- Priority queues

### Graphs

- Representation: adjacency matrix, adjacency list
- Basic graph traversal algorithms: Breadth-First Search (BFS), Depth-First Search (DFS)

---

## Fundamental Algorithms

### Sorting Algorithms

#### Comparison Sorts

- Bubble Sort, Insertion Sort, Selection Sort
- Simplicity and generally poor performance for large datasets

#### Efficient Sorts

- Merge Sort, Quick Sort
- Time and space complexity
- Pivot selection in Quick Sort

#### Non-Comparison Sorts

- Counting Sort, Radix Sort
- Specific use cases and time complexity

### Searching Algorithms

#### Linear Search

- Basic concept and time complexity

#### Binary Search

- Requirements: sorted data
- Algorithm and time complexity

### Greedy Algorithms

- Understanding the greedy approach
- When it leads to an optimal solution (e.g., activity selection, coin change)

### Dynamic Programming

- Concepts: overlapping subproblems, optimal substructure
- Identifying suitable problems
- Example problems: Fibonacci sequence, knapsack problem, longest common subsequence

### Graph Algorithms

#### BFS and DFS

- Applications: finding paths, connected components

#### Shortest Path Algorithms

- Dijkstra's algorithm (for non-negative edge weights)

#### Minimum Spanning Tree Algorithms

- Prim's algorithm, Kruskal's algorithm

---

## Key Concepts to Understand

### Time Complexity (Big O Notation)

- Analyzing algorithm efficiency
- Determining time complexity for data structures and algorithms

### Space Complexity

- Analyzing memory usage of algorithms and data structures

### Recursion

- Understanding recursive functions and their applications
- Converting recursive solutions to iterative ones and vice versa

### Bit Manipulation

- Basic bitwise operations: AND, OR, XOR, NOT, shifts
- Applications in efficient problem solving
